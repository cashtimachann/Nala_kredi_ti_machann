name: Deploy to Digital Ocean

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual trigger

env:
  SERVER_IP: 142.93.78.111
  DEPLOY_PATH: /var/www/nala-credit
  ADMIN_DOMAIN: admin.nalakreditimachann.com
  BRANCH_DOMAIN: branch.nalakreditimachann.com

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      
      - name: ğŸ” Setup SSH
        run: |
          mkdir -p ~/.ssh
          # Decode base64 SSH key and write to file
          echo "${{ secrets.SSH_PRIVATE_KEY_BASE64 }}" | base64 -d > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ env.SERVER_IP }} >> ~/.ssh/known_hosts
          
          # Verify key format
          echo "Checking SSH key format..."
          head -1 ~/.ssh/deploy_key
          tail -1 ~/.ssh/deploy_key
          
          # Test SSH connection
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no root@${{ env.SERVER_IP }} 'echo "SSH connection successful!"'
      
      - name: ğŸ“‹ Display deployment info
        run: |
          echo "ğŸš€ Deploying to: ${{ env.SERVER_IP }}"
          echo "ğŸ“ Deploy path: ${{ env.DEPLOY_PATH }}"
          echo "ğŸŒ Admin Domain: ${{ env.ADMIN_DOMAIN }}"
          echo "ğŸŒ Branch Domain: ${{ env.BRANCH_DOMAIN }}"
          echo "ğŸ“¦ Commit: ${{ github.sha }}"
          echo "ğŸ‘¤ Author: ${{ github.actor }}"
      
      - name: ğŸ§¹ Prepare deployment files
        run: |
          # Create deployment package excluding unnecessary files
          # Using --warning=no-file-changed to ignore file changes during packaging
          tar czf deploy.tar.gz \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='node_modules' \
            --exclude='frontend-web/node_modules' \
            --exclude='backend/NalaCreditAPI/bin' \
            --exclude='backend/NalaCreditAPI/obj' \
            --exclude='*.md' \
            --exclude='*.sh' \
            --exclude='deploy.tar.gz' \
            --warning=no-file-changed \
            . || { [[ $? -eq 1 ]] && echo "Warning: Some files changed during tar (expected)"; }
      
      - name: ğŸ“¤ Upload code to server
        run: |
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy.tar.gz root@${{ env.SERVER_IP }}:/tmp/
      
      - name: ğŸ”„ Deploy on server
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=10 root@${{ env.SERVER_IP }} << 'ENDSSH'
            set -e
            
            echo "ğŸ“¦ Extracting new code..."
            cd ${{ env.DEPLOY_PATH }}
            
            # Backup current deployment
            BACKUP_DIR="/var/backups/nala-credit/deploy-$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$BACKUP_DIR"
            
            # Backup critical files
            if [ -f .env ]; then
              cp .env "$BACKUP_DIR/"
            fi
            if [ -f nginx.conf ]; then
              cp nginx.conf "$BACKUP_DIR/"
            fi
            
            echo "ğŸ’¾ Backup saved to: $BACKUP_DIR"
            
            # Extract new code
            tar xzf /tmp/deploy.tar.gz -C ${{ env.DEPLOY_PATH }}
            rm /tmp/deploy.tar.gz
            
            # Always restore critical files from backup (don't overwrite)
            if [ -f "$BACKUP_DIR/.env" ]; then
              cp "$BACKUP_DIR/.env" .env
              echo "âœ… Restored .env from backup"
            fi
            
            if [ -f "$BACKUP_DIR/nginx.conf" ]; then
              cp "$BACKUP_DIR/nginx.conf" nginx.conf
              echo "âœ… Restored nginx.conf with SSL config from backup"
            fi
            
            echo "ğŸ—ï¸  Building Docker images..."
            # Build each service separately to avoid memory issues
            echo "Building backend..."
            docker compose build --no-cache api
            
            echo "Building frontend admin..."
            docker compose build --no-cache frontend
            
            echo "Building frontend branch (this may take a while)..."
            docker compose build --no-cache --memory=2g frontend-branch || {
              echo "âš ï¸  Frontend branch build failed, using existing image"
            }
            
            echo "ï¿½ Setting up downloads folder..."
            # Create downloads directory structure
            mkdir -p /var/www/downloads/desktop
            
            # Copy download page and files
            if [ -d "frontend-desktop/downloads" ]; then
              cp -r frontend-desktop/downloads/* /var/www/downloads/
              echo "âœ… Downloads folder updated"
            fi
            
            # Set proper permissions
            chown -R www-data:www-data /var/www/downloads
            chmod -R 755 /var/www/downloads
            
            echo "ï¿½ğŸ”„ Restarting services..."
            docker compose up -d
            
            echo "â³ Waiting for services to start..."
            sleep 10
            
            echo "âœ… Deployment complete!"
            
            # Show status
            echo ""
            echo "ğŸ“Š Container Status:"
            docker compose ps
            
            echo ""
            echo "ğŸŒ Application available at:"
            echo "   Admin:  https://${{ env.ADMIN_DOMAIN }}"
            echo "   Branch: https://${{ env.BRANCH_DOMAIN }}"
          ENDSSH
      
      - name: ğŸ§ª Health check
        run: |
          echo "ğŸ¥ Performing health check..."
          
          # Wait for services to fully start
          sleep 20
          
          # Check Admin Domain
          echo "Checking Admin Domain (${{ env.ADMIN_DOMAIN }})..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.ADMIN_DOMAIN }} || echo "000")
          echo "Admin HTTP Status: $HTTP_STATUS"
          
          # Check Branch Domain
          echo "Checking Branch Domain (${{ env.BRANCH_DOMAIN }})..."
          BRANCH_HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.BRANCH_DOMAIN }} || echo "000")
          echo "Branch HTTP Status: $BRANCH_HTTP_STATUS"
          
          if [ "$HTTP_STATUS" != "301" ] && [ "$HTTP_STATUS" != "200" ]; then
            echo "âš ï¸  Admin HTTP redirect check: $HTTP_STATUS (expected 301 or 200)"
          else
            echo "âœ… Admin HTTP redirect working"
          fi
          
          if [ "$BRANCH_HTTP_STATUS" != "301" ] && [ "$BRANCH_HTTP_STATUS" != "200" ]; then
            echo "âš ï¸  Branch HTTP redirect check: $BRANCH_HTTP_STATUS (expected 301 or 200)"
          else
            echo "âœ… Branch HTTP redirect working"
          fi
          
          # Check HTTPS with retries
          echo "Checking HTTPS..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          HTTPS_STATUS="000"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --insecure https://${{ env.ADMIN_DOMAIN }} || echo "000")
            echo "Admin HTTPS Attempt $((RETRY_COUNT + 1)): Status $HTTPS_STATUS"
            
            if [ "$HTTPS_STATUS" = "200" ]; then
              echo "âœ… Admin HTTPS check passed!"
              break
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              sleep 10
            fi
          done
          
          # Check Branch HTTPS
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            BRANCH_HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --insecure https://${{ env.BRANCH_DOMAIN }} || echo "000")
            echo "Branch HTTPS Attempt $((RETRY_COUNT + 1)): Status $BRANCH_HTTPS_STATUS"
            
            if [ "$BRANCH_HTTPS_STATUS" = "200" ]; then
              echo "âœ… Branch HTTPS check passed!"
              break
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              sleep 10
            fi
          done
          
          # Final verification via SSH (more reliable)
          echo ""
          echo "Verifying containers on server..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no root@${{ env.SERVER_IP }} << 'ENDSSH'
            cd ${{ env.DEPLOY_PATH }}
            RUNNING=$(docker compose ps --filter "status=running" -q | wc -l)
            TOTAL=$(docker compose ps -q | wc -l)
            echo "Containers: $RUNNING/$TOTAL running"
            
            if [ $RUNNING -eq $TOTAL ]; then
              echo "âœ… All containers are running!"
              exit 0
            else
              echo "âš ï¸  Some containers not running"
              docker compose ps
              exit 1
            fi
          ENDSSH
          
          echo ""
          echo "âœ… Deployment health check complete!"
      
      - name: ğŸ”” Deployment summary
        if: always()
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  Deployment Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Status: ${{ job.status }}"
          echo "Commit: ${{ github.sha }}"
          echo "Author: ${{ github.actor }}"
          echo "Admin URL: https://${{ env.ADMIN_DOMAIN }}"
          echo "Branch URL: https://${{ env.BRANCH_DOMAIN }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: ğŸ’¬ Notify on failure
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "Check the logs above for details."
          # You can add Slack/Discord webhook notification here
